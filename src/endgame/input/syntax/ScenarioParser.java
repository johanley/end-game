/* Generated By:JavaCC: Do not edit this line. ScenarioParser.java */
package endgame.input.syntax;

import java.io.*;
import java.util.*;
import hirondelle.date4j.*;
import endgame.Scenario;
import endgame.model.*;
import endgame.account.*;
import endgame.account.tfsa.*;
import endgame.account.rif.*;
import endgame.account.nra.*;
import endgame.bank.*;
import endgame.entitlements.*;
import endgame.tax.*;
import endgame.tax.provincial.*;
import endgame.security.stock.*;
import endgame.security.stock.price.*;
import endgame.security.stock.liquidation.*;
import endgame.security.stock.commission.*;
import endgame.security.stock.transaction.*;
import endgame.security.pension.annuity.*;
import endgame.security.gic.*;
import endgame.survival.*;
import endgame.transaction.*;
import endgame.util.*;

/** Input the name of a scenario file, output a {@link Scenario} object holding its data in memory. */
public class ScenarioParser implements ScenarioParserConstants {

  /*
   USING LEXICAL STATES IS TRICKY.
   I find it's much simpler to ensure that tokens are easily distinguishable.
   Remember that longest wins; in the case of a tie, then first-in-parser-file wins.
   Private tokens (with '#') only match as part of a bigger token, and never on their own.
   
   My control of whitespace needs improvement.
  */

  /** Value: {@value}. */
  public static final String SYNTAX_VERSION = "v1.0.0";

  /**
   Run this parser as a stand-alone class.
   Pass in the scenario file location as the first and only arg on the command line.
  */
  public static void main(String... args) throws ParseException, IOException {
    Scenario scenario = parse(args[0]);
    log(scenario.toString());
  }

  /** Parse a scenario file into a Scenario object. */
  public static Scenario parse(String scenarioFile) throws ParseException, IOException {
    ScenarioParser parser = buildFrom(scenarioFile);
    return parser.parseInput();
  }

  /** Factory method to make a parser object. */
  private static ScenarioParser buildFrom(String scenarioFile) throws ParseException, IOException {
    FileInputStream fis = new FileInputStream(scenarioFile);
    InputStreamReader in = new InputStreamReader(fis, "UTF-8");
    ScenarioParser result = new ScenarioParser(in);
    result.scenario.scenarioFile = scenarioFile;
    return result;
  }

  /**  Parse a scenario file into a {@link Scenario} object.  */
  private Scenario parseInput() throws ParseException, IOException {
    log("Parsing file: " + scenario.scenarioFile);
    all();
    createImplicitTransactionsForInitialHoldings();
    return scenario;
  }

  private void createImplicitTransactionsForInitialHoldings() {
    GicTransactions.accrueAndRedeemInitialPositions(scenario);
  }

  /**
   THE OBJECTIVE OF THIS CLASS: to insert the scenario data from a text file into this object,
   where it can be readily accessed later, in the course of running the simulation.
  */
  private Scenario scenario = new Scenario();

  private static void log(String msg) {
    Log.log(msg);
  }

  private static String noQuotes(String input) {
    return input.replace("\u005c"", "");
  }

/*
 This method defines the order of appearance of all items in the file.
 The order of items is not flexible. It needs to follow this pattern.
*/
  final public void all() throws ParseException {
    version();
    description();
    numIterations();
    simulationStartDate();
    simulationEndDate();
    dateOfBirth();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 52:
      annualTestForSurvival();
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
    sex();
    yearZeroAmounts();
    oas();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 149:
      cpp();
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 114:
      rifMinimumWithdrawals();
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    federalTaxes();
    provincialTax();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 95:
      stocks();
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 107:
      commission();
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 100:
      stockPricePolicy();
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 111:
      tfsaRoom();
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    accounts();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 124:
      sequentialLiquidation();
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 129:
      annualTfsaTopUp();
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 165:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_1;
      }
      smallPaycheck();
    }
    transactions();
    jj_consume_token(0);
  }

/*
 A hard-coded version number for the syntax of the scenario file.
 This must be updated with every published change in the syntax, no matter how trivial.
 
 The java code that talks to this file is hard-coded to a specific syntax-version.
 This will break old scenario files, if the user updates the code.
 Using a project branch for each release can mitigate this problem.

 I don't know if there's a way to reference the public field defined above; it's thus repeated here.
*/
  final public void version() throws ParseException {
    jj_consume_token(47);
    jj_consume_token(EQUALS);
    jj_consume_token(48);
  }

  final public void description() throws ParseException {
    jj_consume_token(49);
    jj_consume_token(EQUALS);
    jj_consume_token(QUOTED_TEXT);
                                         scenario.description = noQuotes(token.image.trim());
  }

  final public void numIterations() throws ParseException {
    jj_consume_token(50);
    jj_consume_token(EQUALS);
    jj_consume_token(NUM);
    scenario.numIterations = Integer.valueOf(token.image);
    if (scenario.numIterations > 100) {
      {if (true) throw new IllegalArgumentException("Number of iterations exceeds the max (100): " + scenario.numIterations);}
    }
  }

  final public void dateOfBirth() throws ParseException {
    jj_consume_token(51);
    jj_consume_token(EQUALS);
    jj_consume_token(YYYY_MM_DD);
                                              scenario.dateOfBirth = token.image;
  }

  final public void annualTestForSurvival() throws ParseException {
    jj_consume_token(52);
                              scenario.annualTestForSurvival = true;
  }

  final public void simulationStartDate() throws ParseException {
    jj_consume_token(53);
    jj_consume_token(EQUALS);
    jj_consume_token(YYYY_MM_DD);
                                                      scenario.startDate = token.image;
  }

  final public void simulationEndDate() throws ParseException {
    jj_consume_token(54);
    jj_consume_token(EQUALS);
    jj_consume_token(YYYY_MM_DD);
                                                   scenario.endDate = token.image;
  }

  final public void sex() throws ParseException {
    jj_consume_token(55);
    jj_consume_token(EQUALS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 56:
      jj_consume_token(56);
      break;
    case 57:
      jj_consume_token(57);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                        scenario.sex = Sex.valueOf(token.image.toUpperCase());
  }

  final public void federalTaxes() throws ParseException {
 String initialYear = "";
 String personalAmt = ""; String personalAmtAdditional = ""; String personalAmtThreshold = "";
 String ageAmt = ""; String ageAmtThreshold = "";
 String pensionIncomeMax = "";
 TaxBrackets taxBrackets = null;
 TaxBrackets rifWithholdingTaxBrackets = null;
 String taxCapGainFrac=""; String stdRetAge=""; String divTaxNum=""; String divTaxDen="";
    jj_consume_token(58);
    jj_consume_token(BLOCK_START);
    jj_consume_token(59);
    jj_consume_token(EQUALS);
    jj_consume_token(NUM);
                                       initialYear = token.image;
    jj_consume_token(60);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                            personalAmt = token.image;
    jj_consume_token(61);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                                       personalAmtAdditional = token.image;
    jj_consume_token(62);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY_RANGE);
                                                            personalAmtThreshold = token.image;
    jj_consume_token(63);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                        ageAmt = token.image;
    jj_consume_token(64);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                                  ageAmtThreshold = token.image;
    jj_consume_token(65);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                                pensionIncomeMax = token.image;
    taxBrackets = taxBrackets();
    rifWithholdingTaxBrackets = rifWithholdingTaxBrackets();
    jj_consume_token(66);
    jj_consume_token(EQUALS);
    jj_consume_token(NUM);
                                             stdRetAge=token.image;
    jj_consume_token(67);
    jj_consume_token(EQUALS);
    jj_consume_token(DOUBLE);
                                                      taxCapGainFrac=token.image;
    jj_consume_token(68);
    jj_consume_token(EQUALS);
    jj_consume_token(NUM);
                                               divTaxNum=token.image;
    jj_consume_token(69);
    jj_consume_token(EQUALS);
    jj_consume_token(NUM);
                                               divTaxDen=token.image;
    jj_consume_token(BLOCK_END);
    scenario.taxReturn = FederalTaxReturn.valueOf (
      scenario,
      initialYear, scenario.dateOfBirth, personalAmt, personalAmtAdditional, personalAmtThreshold,
      ageAmt, ageAmtThreshold,
      pensionIncomeMax, taxBrackets, rifWithholdingTaxBrackets,
      stdRetAge, taxCapGainFrac, divTaxNum, divTaxDen
    );
  }

  final public TaxBrackets taxBrackets() throws ParseException {
                              TaxBrackets result = new TaxBrackets(); TaxBracket tb = null;
    jj_consume_token(70);
    jj_consume_token(BLOCK_START);
    label_2:
    while (true) {
      tb = taxBracket();
                         result.add(tb);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PERCENT:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_2;
      }
    }
    jj_consume_token(BLOCK_END);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public TaxBrackets rifWithholdingTaxBrackets() throws ParseException {
                                            TaxBrackets result = new TaxBrackets(); TaxBracket tb = null;
    jj_consume_token(71);
    jj_consume_token(BLOCK_START);
    label_3:
    while (true) {
      tb = taxBracket();
                         result.add(tb);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PERCENT:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_3;
      }
    }
    jj_consume_token(BLOCK_END);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public TaxBracket taxBracket() throws ParseException {
                            String rate = ""; String max = "";
    jj_consume_token(PERCENT);
                rate = token.image;
    jj_consume_token(COLON);
    jj_consume_token(MONEY);
                                                            max = token.image;
    {if (true) return TaxBracket.valueOf(rate, max);}
    throw new Error("Missing return statement in function");
  }

  final public void provincialTax() throws ParseException {
 ProvincialTaxFields fields = new ProvincialTaxFields();
    jj_consume_token(72);
    jj_consume_token(BLOCK_START);
    jj_consume_token(73);
    jj_consume_token(EQUALS);
    jj_consume_token(PROV_TERR);
                                         fields.jurisdiction = token.image;
    fields.taxBrackets = taxBrackets();
    jj_consume_token(60);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                             fields.personalAmt = token.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 74:
      jj_consume_token(74);
      jj_consume_token(EQUALS);
      jj_consume_token(MONEY);
                                                     fields.personalAmtSupplement = token.image;
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 62:
      jj_consume_token(62);
      jj_consume_token(EQUALS);
      jj_consume_token(MONEY);
                                                    fields.personalAmtThreshold = token.image;
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 75:
      jj_consume_token(75);
      jj_consume_token(EQUALS);
      jj_consume_token(PERCENT);
                                                  fields.personalAmtRate = token.image;
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    jj_consume_token(63);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                        fields.ageAmt = token.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 64:
      jj_consume_token(64);
      jj_consume_token(EQUALS);
      jj_consume_token(MONEY);
                                                  fields.ageAmtThreshold  = token.image;
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 76:
      jj_consume_token(76);
      jj_consume_token(EQUALS);
      jj_consume_token(MONEY);
                                               fields.ageAmtSupplement  = token.image;
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 77:
      jj_consume_token(77);
      jj_consume_token(EQUALS);
      jj_consume_token(MONEY);
                                                       fields.ageAmtSupplementThreshold  = token.image;
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 78:
      jj_consume_token(78);
      jj_consume_token(EQUALS);
      jj_consume_token(PERCENT);
                                                    fields.ageAmtSupplementRate  = token.image;
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    jj_consume_token(65);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                                fields.pensionIncomeMax = token.image;
    jj_consume_token(79);
    jj_consume_token(EQUALS);
    jj_consume_token(PERCENT);
                                                 fields.dvdGrossUpMult = token.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 80:
      jj_consume_token(80);
      jj_consume_token(EQUALS);
      jj_consume_token(MONEY);
                                              fields.lowIncomeBasic = token.image;
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 81:
      jj_consume_token(81);
      jj_consume_token(EQUALS);
      jj_consume_token(MONEY);
                                            fields.lowIncomeAge = token.image;
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 82:
      jj_consume_token(82);
      jj_consume_token(EQUALS);
      jj_consume_token(MONEY);
                                                   fields.lowIncomeThreshold = token.image;
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 83:
      jj_consume_token(83);
      jj_consume_token(EQUALS);
      jj_consume_token(PERCENT);
                                                fields.lowIncomeRate = token.image;
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 84:
      jj_consume_token(84);
      jj_consume_token(EQUALS);
      jj_consume_token(MONEY);
                                             fields.ageTaxCredit = token.image;
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 85:
      jj_consume_token(85);
      jj_consume_token(EQUALS);
      jj_consume_token(MONEY);
                                                       fields.ageTaxCreditThreshold = token.image;
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 86:
      jj_consume_token(86);
      jj_consume_token(EQUALS);
      jj_consume_token(MONEY);
                                             fields.surtaxThreshold1 = token.image;
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 87:
      jj_consume_token(87);
      jj_consume_token(EQUALS);
      jj_consume_token(PERCENT);
                                          fields.surtaxRate1 = token.image;
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 88:
      jj_consume_token(88);
      jj_consume_token(EQUALS);
      jj_consume_token(MONEY);
                                             fields.surtaxThreshold2 = token.image;
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 89:
      jj_consume_token(89);
      jj_consume_token(EQUALS);
      jj_consume_token(PERCENT);
                                         fields.surtaxRate2 = token.image;
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 90:
      jj_consume_token(90);
      jj_consume_token(EQUALS);
      jj_consume_token(MONEY);
                                             fields.scheduleBThreshold = token.image;
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 91:
      jj_consume_token(91);
      jj_consume_token(EQUALS);
      jj_consume_token(PERCENT);
                                          fields.scheduleBRate = token.image;
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 92:
      jj_consume_token(92);
      jj_consume_token(EQUALS);
      jj_consume_token(MONEY);
                                           fields.liveAloneAmt = token.image;
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 93:
      jj_consume_token(93);
      jj_consume_token(EQUALS);
      jj_consume_token(PERCENT);
                                               fields.pensionIncomeRate = token.image;
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 94:
      fields.healthPremiumTaxBrackets = healthPremiumTaxBrackets();
      break;
    default:
      jj_la1[34] = jj_gen;
      ;
    }
    jj_consume_token(BLOCK_END);
    scenario.provincialTaxReturn = fields.deduceFromFieldsPresent(scenario.taxReturn);
    scenario.taxReturn.setProvincialReturn(scenario.provincialTaxReturn);
  }

  final public TaxBrackets healthPremiumTaxBrackets() throws ParseException {
                                           TaxBrackets result = new TaxBrackets(); TaxBracket tb = null;
    jj_consume_token(94);
    jj_consume_token(BLOCK_START);
    label_4:
    while (true) {
      tb = taxBracket();
                         result.add(tb);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PERCENT:
        ;
        break;
      default:
        jj_la1[35] = jj_gen;
        break label_4;
      }
    }
    jj_consume_token(BLOCK_END);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public void stocks() throws ParseException {
    jj_consume_token(95);
    jj_consume_token(BLOCK_START);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUOTED_TEXT:
        ;
        break;
      default:
        jj_la1[36] = jj_gen;
        break label_5;
      }
      stock();
    }
    jj_consume_token(BLOCK_END);
  }

  final public void stock() throws ParseException {
                 String symbol = ""; String price = ""; Dividend dividend = null;
    jj_consume_token(QUOTED_TEXT);
                  symbol = noQuotes(token.image);
    jj_consume_token(BLOCK_START);
    jj_consume_token(96);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                    price = token.image;
        dividend = dividend();
    jj_consume_token(BLOCK_END);
    Stock stock = Stock.valueOf(symbol, price, dividend, scenario.startDate);
    scenario.stocks.add(stock);
    scenario.transactionals.add(new DividendPayment(stock));
  }

  final public Dividend dividend() throws ParseException {
                        String amount = ""; String when = ""; String growth = "";
    jj_consume_token(97);
    jj_consume_token(BLOCK_START);
    jj_consume_token(WHEN_CONTROL);
                     when = token.image;
    jj_consume_token(98);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                    amount = token.image;
    jj_consume_token(99);
    jj_consume_token(EQUALS);
    jj_consume_token(PERCENT);
                                      growth = token.image;
    jj_consume_token(BLOCK_END);
    {if (true) return Dividend.valueOf(amount, when, growth);}
    throw new Error("Missing return statement in function");
  }

  final public void stockPricePolicy() throws ParseException {
                            String when = "";
    jj_consume_token(100);
    jj_consume_token(BLOCK_START);
    jj_consume_token(WHEN_CONTROL);
                     when = token.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 101:
      fixedGrowthRate();
      break;
    case 102:
      rangedGrowthRate();
      break;
    case 103:
      gaussianGrowthRate();
      break;
    case 106:
      explicitGrowthList();
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(BLOCK_END);
   scenario.transactionals.add(new UpdateStockPrices(when));
  }

  final public void fixedGrowthRate() throws ParseException {
                           String percent = "";
    jj_consume_token(101);
    jj_consume_token(EQUALS);
    jj_consume_token(PERCENT);
                                 percent = token.image;
    scenario.stockPrices = new FixedGrowthRate(percent);
  }

  final public void rangedGrowthRate() throws ParseException {
                            String lower = ""; String upper = "";
    jj_consume_token(102);
    jj_consume_token(EQUALS);
    jj_consume_token(PERCENT);
                                 lower = token.image;
    jj_consume_token(UNDERSCORE);
    jj_consume_token(PERCENT);
                                                                                   upper = token.image;
    scenario.stockPrices = new RangedGrowthRate(lower, upper);
  }

  final public void gaussianGrowthRate() throws ParseException {
                              String mean = ""; String stdDev = "";
    jj_consume_token(103);
    jj_consume_token(104);
    jj_consume_token(EQUALS);
    jj_consume_token(PERCENT);
                                           mean = token.image;
    jj_consume_token(105);
    jj_consume_token(EQUALS);
    jj_consume_token(PERCENT);
                                                                                                  stdDev = token.image;
    scenario.stockPrices = new GaussianGrowthRate(mean, stdDev);
  }

  final public void explicitGrowthList() throws ParseException {
                              String percentList = "";
    jj_consume_token(106);
    jj_consume_token(EQUALS);
    jj_consume_token(PERCENT_LIST);
                                            percentList = token.image;
    scenario.stockPrices = new ExplicitGrowthList(percentList);
  }

  final public void commission() throws ParseException {
    jj_consume_token(107);
    jj_consume_token(EQUALS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 108:
      fixedPercentCommish();
      break;
    case 109:
      fixedAmountCommish();
      break;
    case 110:
      customCommish();
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void fixedPercentCommish() throws ParseException {
                               String percent = "";
    jj_consume_token(108);
    jj_consume_token(PERCENT);
                                percent = token.image;
    scenario.commission = new FixedPercentCommish(percent);
  }

  final public void fixedAmountCommish() throws ParseException {
                              String amount = "";
    jj_consume_token(109);
    jj_consume_token(MONEY);
                             amount = token.image;
    scenario.commission = new FixedAmountCommish(amount);
  }

/* This requires custom coding. Updated the class specified below.*/
  final public void customCommish() throws ParseException {
    jj_consume_token(110);
    scenario.commission = new CustomCommish();
  }

  final public void tfsaRoom() throws ParseException {
                    String initialRoom = ""; String yearlyLimit = "";
    jj_consume_token(111);
    jj_consume_token(BLOCK_START);
    jj_consume_token(112);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                         initialRoom = token.image;
    jj_consume_token(113);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                          yearlyLimit = token.image;
    jj_consume_token(BLOCK_END);
    scenario.tfsaRoom = TfsaRoom.valueOf(initialRoom, yearlyLimit);
  }

  final public void rifMinimumWithdrawals() throws ParseException {
    scenario.rifMinima = new RifMinima(scenario.dateOfBirth);
    jj_consume_token(114);
    jj_consume_token(BLOCK_START);
    label_6:
    while (true) {
      rifMinimumWithdrawal();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUM:
        ;
        break;
      default:
        jj_la1[39] = jj_gen;
        break label_6;
      }
    }
    jj_consume_token(BLOCK_END);
  }

  final public void rifMinimumWithdrawal() throws ParseException {
                                String age = ""; String percent = ""; String noPercentSign = "";
    jj_consume_token(NUM);
           age = token.image;
    jj_consume_token(EQUALS);
    jj_consume_token(PERCENT);
                                                         percent = token.image;
   noPercentSign = percent.substring(0, percent.length()-1);
   scenario.rifMinima.addTableRow(Integer.valueOf(age), Double.valueOf(noPercentSign)/100.0D);
  }

  final public void accounts() throws ParseException {
                    BankAccount bank = null; Tfsa tfsa = null; Rif rif = null; Nra nra = null;
    jj_consume_token(115);
    jj_consume_token(BLOCK_START);
    bank = bank();
                    scenario.bank = bank;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RIF:
      rif = rif();
                   scenario.rif = rif;
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TFSA:
      tfsa = tfsa();
                      scenario.tfsa = tfsa;
      break;
    default:
      jj_la1[41] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NRA:
      nra = nra();
                    scenario.nra = nra;
      break;
    default:
      jj_la1[42] = jj_gen;
      ;
    }
    jj_consume_token(BLOCK_END);
  }

  final public BankAccount bank() throws ParseException {
                       String cash = ""; String limit = "";
    jj_consume_token(BANK);
    jj_consume_token(BLOCK_START);
    jj_consume_token(116);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                  cash = token.image;
    jj_consume_token(117);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                                 limit = token.image;
    jj_consume_token(BLOCK_END);
    {if (true) return BankAccount.valueOf(cash, limit);}
    throw new Error("Missing return statement in function");
  }

  final public Rif rif() throws ParseException {
   String cash = ""; String conversionDate="";
   Set<StockPosition> stockPositions = new LinkedHashSet<StockPosition>(); Rif result = null;
   Set<GtdInvestmentCert> gicPositions = new LinkedHashSet<GtdInvestmentCert>();
    jj_consume_token(RIF);
    jj_consume_token(BLOCK_START);
    jj_consume_token(118);
    jj_consume_token(EQUALS);
    jj_consume_token(YYYY_MM_DD);
                                                  conversionDate = token.image;
    jj_consume_token(116);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                   cash = token.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 119:
      stockPositions = stockPositions();
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 121:
      gicPositions = gicPositions();
      break;
    default:
      jj_la1[44] = jj_gen;
      ;
    }
    jj_consume_token(BLOCK_END);
     result = Rif.valueOf(cash, stockPositions, gicPositions, scenario.taxReturn, conversionDate);
     scenario.rifValueJan1 = result.value();
     {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public Tfsa tfsa() throws ParseException {
  String cash = "";  Set<StockPosition> stockPositions = new LinkedHashSet<StockPosition>();
  Set<GtdInvestmentCert> gicPositions = new LinkedHashSet<GtdInvestmentCert>();
    jj_consume_token(TFSA);
    jj_consume_token(BLOCK_START);
    jj_consume_token(116);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                   cash = token.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 119:
      stockPositions = stockPositions();
      break;
    default:
      jj_la1[45] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 121:
      gicPositions = gicPositions();
      break;
    default:
      jj_la1[46] = jj_gen;
      ;
    }
    jj_consume_token(BLOCK_END);
     {if (true) return Tfsa.valueOf(cash, stockPositions, gicPositions, scenario.tfsaRoom);}
    throw new Error("Missing return statement in function");
  }

  final public Nra nra() throws ParseException {
  String cash = "";
  Set<StockPosition> stockPositions = new LinkedHashSet<StockPosition>();
  Set<GtdInvestmentCert> gicPositions = new LinkedHashSet<GtdInvestmentCert>();
  Set<BookValue> bookValues = new LinkedHashSet<BookValue>();
    jj_consume_token(NRA);
    jj_consume_token(BLOCK_START);
    jj_consume_token(116);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                   cash = token.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 119:
      stockPositions = stockPositions();
      break;
    default:
      jj_la1[47] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 121:
      gicPositions = gicPositions();
      break;
    default:
      jj_la1[48] = jj_gen;
      ;
    }
    bookValues = bookValues();
    jj_consume_token(BLOCK_END);
     {if (true) return Nra.valueOf(cash, stockPositions, gicPositions, bookValues, scenario.taxReturn, scenario.capitalGainLoss);}
    throw new Error("Missing return statement in function");
  }

  final public Set<StockPosition> stockPositions() throws ParseException {
                                       String symbol = ""; String shares = ""; Set<StockPosition> result = new LinkedHashSet<StockPosition>();
    jj_consume_token(119);
    jj_consume_token(BLOCK_START);
    label_7:
    while (true) {
      jj_consume_token(NUM);
                shares = token.image;
      jj_consume_token(QUOTED_TEXT);
                                                          symbol = noQuotes(token.image);
        result.add(StockPosition.valueOf(scenario.stockFrom(symbol), shares));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUM:
        ;
        break;
      default:
        jj_la1[49] = jj_gen;
        break label_7;
      }
    }
    jj_consume_token(BLOCK_END);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public Set<BookValue> bookValues() throws ParseException {
                               String symbol = ""; String amount = ""; Set<BookValue> result = new LinkedHashSet<BookValue>();
    jj_consume_token(120);
    jj_consume_token(BLOCK_START);
    label_8:
    while (true) {
      jj_consume_token(MONEY);
                  amount = token.image;
      jj_consume_token(QUOTED_TEXT);
                        symbol = noQuotes(token.image);
        result.add(BookValue.valueOf(symbol, amount));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MONEY:
        ;
        break;
      default:
        jj_la1[50] = jj_gen;
        break label_8;
      }
    }
    jj_consume_token(BLOCK_END);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public Set<GtdInvestmentCert> gicPositions() throws ParseException {
  String principal=""; String soldBy=""; String interestRate=""; String term=""; String redemptionDate="";
  Set<GtdInvestmentCert> result = new LinkedHashSet<GtdInvestmentCert>();
    jj_consume_token(121);
    jj_consume_token(BLOCK_START);
    label_9:
    while (true) {
      jj_consume_token(QUOTED_TEXT);
                    soldBy = noQuotes(token.image);
      jj_consume_token(MONEY);
              principal = token.image;
      jj_consume_token(PERCENT);
                interestRate = token.image;
      jj_consume_token(NUM);
            term = token.image;
      jj_consume_token(122);
      jj_consume_token(123);
      jj_consume_token(YYYY_MM_DD);
                             redemptionDate = token.image;
      result.add(GtdInvestmentCert.fromRedemptionDate(principal, soldBy, interestRate, redemptionDate, term));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUOTED_TEXT:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_9;
      }
    }
    jj_consume_token(BLOCK_END);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public void sequentialLiquidation() throws ParseException {
   List<Account> accounts = new ArrayList<Account>(); List<Stock> stocks = new ArrayList<Stock>();
   String avoid=""; String when=""; String amount=""; String percent="";
    jj_consume_token(124);
    jj_consume_token(BLOCK_START);
    jj_consume_token(125);
    jj_consume_token(EQUALS);
    jj_consume_token(NUM);
                                             avoid = token.image;
    jj_consume_token(126);
    jj_consume_token(EQUALS);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NRA:
        jj_consume_token(NRA);
                                             accounts.add(scenario.nra);
        break;
      case RIF:
        jj_consume_token(RIF);
                                             accounts.add(scenario.rif);
        break;
      case TFSA:
        jj_consume_token(TFSA);
                                              accounts.add(scenario.tfsa);
        break;
      default:
        jj_la1[52] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[53] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RIF:
      case TFSA:
      case NRA:
        ;
        break;
      default:
        jj_la1[54] = jj_gen;
        break label_10;
      }
    }
    jj_consume_token(127);
    jj_consume_token(EQUALS);
    jj_consume_token(QUOTED_TEXT);
                                                   for(String ticker : Util.chopList(noQuotes(token.image))) {
                                              stocks.add(scenario.stockFrom(ticker));
                                          }
    label_11:
    while (true) {
      jj_consume_token(128);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MONEY:
        jj_consume_token(MONEY);
                          amount=token.image;percent="";
        break;
      case PERCENT:
        jj_consume_token(PERCENT);
                                                                       percent=token.image;amount="";
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(WHEN_CONTROL);
                                                                                                                        when=token.image;
          scenario.transactionals.add(SequentialLiquidation.valueOf(avoid,accounts,stocks,amount,percent,when));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 128:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_11;
      }
    }
    jj_consume_token(BLOCK_END);
  }

  final public void annualTfsaTopUp() throws ParseException {
   List<Account> accounts = new ArrayList<Account>(); List<Stock> stocks = new ArrayList<Stock>();
   String when= ""; Transactional tfsaTopUp = null;
    jj_consume_token(129);
    jj_consume_token(BLOCK_START);
    jj_consume_token(126);
    jj_consume_token(EQUALS);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NRA:
        jj_consume_token(NRA);
                                             accounts.add(scenario.nra);
        break;
      case RIF:
        jj_consume_token(RIF);
                                                                                   accounts.add(scenario.rif);
        break;
      default:
        jj_la1[57] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[58] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RIF:
      case NRA:
        ;
        break;
      default:
        jj_la1[59] = jj_gen;
        break label_12;
      }
    }
    jj_consume_token(127);
    jj_consume_token(EQUALS);
    jj_consume_token(QUOTED_TEXT);
                                                  for(String ticker : Util.chopList(noQuotes(token.image))) {
                                              stocks.add(scenario.stockFrom(ticker));
                                          }
    jj_consume_token(WHEN_CONTROL);
                        when = token.image;
    jj_consume_token(BLOCK_END);
     tfsaTopUp = new TfsaTopUp(when, accounts, stocks);
     scenario.transactionals.add(tfsaTopUp);
  }

/* In this case, items inside the transaction block can come in any order. */
  final public void transactions() throws ParseException {
    jj_consume_token(130);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPEND_BANK_BALANCE_ABOVE:
      case 131:
      case 155:
      case 156:
      case 158:
      case 159:
      case 160:
      case 161:
      case 164:
      case 166:
      case 167:
        ;
        break;
      default:
        jj_la1[60] = jj_gen;
        break label_13;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 131:
        bankDebitCredit();
        break;
      case SPEND_BANK_BALANCE_ABOVE:
        spendBankBalanceAbove();
        break;
      case 155:
      case 156:
        buySellStock();
        break;
      case 158:
        buyGic();
        break;
      case 159:
      case 160:
        transferStock();
        break;
      case 161:
        moveStock();
        break;
      case 164:
        moveCash();
        break;
      case 166:
        annuityPayment();
        break;
      case 167:
        stockSplit();
        break;
      default:
        jj_la1[61] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(BLOCK_END);
    PayTaxes payTaxes = new PayTaxes("on *-12-31");
    scenario.transactionals.add(payTaxes);
  }

  final public Account nonBankAccount() throws ParseException {
                             Account account = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TFSA:
      jj_consume_token(TFSA);
              account = scenario.tfsa;
      break;
    case RIF:
      jj_consume_token(RIF);
                                                   account = scenario.rif;
      break;
    case NRA:
      jj_consume_token(NRA);
                                                                                       account = scenario.nra;
      break;
    default:
      jj_la1[62] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return account;}
    throw new Error("Missing return statement in function");
  }

  final public Cashable account() throws ParseException {
                       Cashable cashable = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TFSA:
      jj_consume_token(TFSA);
             cashable=scenario.tfsa;
      break;
    case RIF:
      jj_consume_token(RIF);
                                               cashable=scenario.rif;
      break;
    case NRA:
      jj_consume_token(NRA);
                                                                                cashable=scenario.nra;
      break;
    case BANK:
      jj_consume_token(BANK);
                                                                                                                  cashable=scenario.bank;
      break;
    default:
      jj_la1[63] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return cashable;}
    throw new Error("Missing return statement in function");
  }

  final public void bankDebitCredit() throws ParseException {
                          String amount = ""; String when = "";
    jj_consume_token(131);
    jj_consume_token(MONEY);
                                 amount = token.image;
    jj_consume_token(WHEN_CONTROL);
                                                                         when = token.image;
    BankDebitCredit spending = new BankDebitCredit(new Money(amount), when);
    scenario.transactionals.add(spending);
  }

  final public void spendBankBalanceAbove() throws ParseException {
                                String amount = ""; String when = "";
    jj_consume_token(SPEND_BANK_BALANCE_ABOVE);
    jj_consume_token(MONEY);
                                        amount = token.image;
    jj_consume_token(WHEN_CONTROL);
                                                                                when = token.image;
    SplurgeSpending splurgeSpending = new SplurgeSpending(new Money(amount), when);
    scenario.transactionals.add(splurgeSpending);
  }

  final public void yearZeroAmounts() throws ParseException {
                          String netIncBefAdj=""; String netInc=""; String oasInc=""; String empInc=""; String tfsaRoom="";
    jj_consume_token(132);
    jj_consume_token(BLOCK_START);
    jj_consume_token(133);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                                       netIncBefAdj=token.image;
    jj_consume_token(134);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                    netInc=token.image;
    jj_consume_token(135);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                    oasInc=token.image;
    jj_consume_token(136);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                           empInc=token.image;
    jj_consume_token(BLOCK_END);
   scenario.yearZero = new YearZero(netIncBefAdj, netInc, oasInc, empInc);
  }

  final public void oas() throws ParseException {
  String amt = ""; String start = ""; String paymentDay = "";
  String monthlyRew=""; String boostAge=""; String boostPercent=""; String clawThres=""; String clawPercent="";
  String exempt = ""; String startWinBegin=""; String startWinEnd="";
    jj_consume_token(137);
    jj_consume_token(BLOCK_START);
    jj_consume_token(138);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                                  amt = token.image;
    jj_consume_token(139);
    jj_consume_token(EQUALS);
    jj_consume_token(YYYY_MM);
                                           start = token.image;
    jj_consume_token(140);
    jj_consume_token(EQUALS);
    jj_consume_token(NUM);
                                        paymentDay = token.image;
    jj_consume_token(141);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                             clawThres=token.image;
    jj_consume_token(142);
    jj_consume_token(EQUALS);
    jj_consume_token(PERCENT);
                                            clawPercent=token.image;
    jj_consume_token(143);
    jj_consume_token(EQUALS);
    jj_consume_token(PERCENT);
                                          monthlyRew=token.image;
    jj_consume_token(144);
    jj_consume_token(EQUALS);
    jj_consume_token(NUM);
                                 boostAge=token.image;
    jj_consume_token(145);
    jj_consume_token(EQUALS);
    jj_consume_token(PERCENT);
                                          boostPercent=token.image;
    jj_consume_token(146);
    jj_consume_token(EQUALS);
    jj_consume_token(NUM);
                                          startWinBegin=token.image;
    jj_consume_token(147);
    jj_consume_token(EQUALS);
    jj_consume_token(NUM);
                                        startWinEnd=token.image;
    jj_consume_token(148);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                                 exempt=token.image;
    jj_consume_token(BLOCK_END);
    OasPayment oas = OasPayment.valueOf(
      start, amt, scenario.dateOfBirth, paymentDay, monthlyRew,
      boostAge, boostPercent, clawThres, clawPercent, startWinBegin, startWinEnd, exempt
    );
    scenario.transactionals.add(oas);
  }

  final public void cpp() throws ParseException {
  String nominalAmt = ""; String start = ""; String paymentDay = "";
  String monReward=""; String monPenalty=""; String nominalStart=""; String startWinBeg=""; String startWinEnd="";
  String survivorAmt=""; String survivorDate="";
    jj_consume_token(149);
    jj_consume_token(BLOCK_START);
    jj_consume_token(150);
    jj_consume_token(EQUALS);
    jj_consume_token(MONEY);
                                                    nominalAmt = token.image;
    jj_consume_token(139);
    jj_consume_token(EQUALS);
    jj_consume_token(YYYY_MM);
                                           start = token.image;
    jj_consume_token(140);
    jj_consume_token(EQUALS);
    jj_consume_token(NUM);
                                        paymentDay = token.image;
    jj_consume_token(143);
    jj_consume_token(EQUALS);
    jj_consume_token(PERCENT);
                                          monReward=token.image;
    jj_consume_token(151);
    jj_consume_token(EQUALS);
    jj_consume_token(PERCENT);
                                           monPenalty=token.image;
    jj_consume_token(146);
    jj_consume_token(EQUALS);
    jj_consume_token(NUM);
                                          startWinBeg=token.image;
    jj_consume_token(152);
    jj_consume_token(EQUALS);
    jj_consume_token(NUM);
                                     nominalStart=token.image;
    jj_consume_token(147);
    jj_consume_token(EQUALS);
    jj_consume_token(NUM);
                                        startWinEnd=token.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 153:
      jj_consume_token(153);
      jj_consume_token(EQUALS);
      jj_consume_token(MONEY);
                                                  survivorAmt=token.image;
      jj_consume_token(154);
      jj_consume_token(EQUALS);
      jj_consume_token(YYYY_MM_DD);
                                                      survivorDate=token.image;
      break;
    default:
      jj_la1[64] = jj_gen;
      ;
    }
    jj_consume_token(BLOCK_END);
    CppPayment cpp = CppPayment.valueOf(
      start, nominalAmt, scenario.dateOfBirth, paymentDay, monReward, monPenalty, nominalStart, startWinBeg, startWinEnd,
      survivorAmt, survivorDate
    );
    scenario.transactionals.add(cpp);
  }

  final public void buySellStock() throws ParseException {
  Account account = null; String action=""; String numShares=""; String symbol=""; String when="";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 155:
      jj_consume_token(155);
      break;
    case 156:
      jj_consume_token(156);
      break;
    default:
      jj_la1[65] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                action=token.image;
    account = nonBankAccount();
    jj_consume_token(NUM);
           numShares=token.image;
    jj_consume_token(157);
    jj_consume_token(QUOTED_TEXT);
                 symbol=noQuotes(token.image);
    jj_consume_token(WHEN_CONTROL);
                  when=token.image;
   scenario.transactionals.add(new BuySellStock(when, numShares, account, symbol, action));
  }

/* Buying a GIC results in both a buy-transaction and a redemption-transaction. */
  final public void buyGic() throws ParseException {
  Account account=null; String soldBy=""; String principal=""; String interestRate="";
  String term=""; String date="";
    jj_consume_token(158);
    account = nonBankAccount();
    jj_consume_token(QUOTED_TEXT);
                 soldBy = noQuotes(token.image);
    jj_consume_token(MONEY);
           principal = token.image;
    jj_consume_token(PERCENT);
             interestRate = token.image;
    jj_consume_token(NUM);
         term = token.image;
    jj_consume_token(122);
    jj_consume_token(COLON);
    jj_consume_token(YYYY_MM_DD);
                        date = token.image;
    GicTransactions.buyAccrueAndRedeem(scenario, date, account, principal, soldBy, interestRate, term);
  }

  final public void transferStock() throws ParseException {
  Account account = null; String action=""; String numShares=""; String symbol=""; String when=""; String amount=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 159:
      jj_consume_token(159);
      break;
    case 160:
      jj_consume_token(160);
      break;
    default:
      jj_la1[66] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                                action=token.image;
    account = nonBankAccount();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUM:
      jj_consume_token(NUM);
            numShares=token.image;
      jj_consume_token(157);
      break;
    case MONEY:
      jj_consume_token(MONEY);
                                                        amount=token.image;
      break;
    default:
      jj_la1[67] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(QUOTED_TEXT);
                 symbol=noQuotes(token.image);
    jj_consume_token(WHEN_CONTROL);
                  when=token.image;
    if (amount == null) {
      scenario.transactionals.add(TransferStock.byNumShares(account, action, numShares, symbol, when));
    }
    else {
      scenario.transactionals.add(TransferStock.byMarketValue(account, action, amount, symbol, when));
    }
  }

  final public void moveStock() throws ParseException {
  Account from=null; Account to=null; String numShares=""; String symbol="";
  String when=""; String amount=null;
    jj_consume_token(161);
    jj_consume_token(162);
    from = nonBankAccount();
    jj_consume_token(163);
    to = nonBankAccount();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUM:
      jj_consume_token(NUM);
           numShares=token.image;
      jj_consume_token(157);
      break;
    case MONEY:
      jj_consume_token(MONEY);
                                                       amount=token.image;
      break;
    default:
      jj_la1[68] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(QUOTED_TEXT);
                 symbol=noQuotes(token.image);
    jj_consume_token(WHEN_CONTROL);
                  when=token.image;
    if (amount == null) {
      scenario.transactionals.add(MoveStock.byNumShares(from, to, numShares, symbol, when));
    }
    else {
      scenario.transactionals.add(MoveStock.byMarketValue(from, to, amount, symbol, when));
    }
  }

  final public void moveCash() throws ParseException {
  Cashable from=null; Cashable to=null; String when=""; String amount=null;
    jj_consume_token(164);
    jj_consume_token(162);
    from = account();
    jj_consume_token(163);
    to = account();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MONEY:
      jj_consume_token(MONEY);
            amount=token.image;
      break;
    default:
      jj_la1[69] = jj_gen;
      ;
    }
    jj_consume_token(WHEN_CONTROL);
                  when=token.image;
    if (amount == null) {
      scenario.transactionals.add(MoveCash.fullBalance(from, to, when));
    }
    else {
      scenario.transactionals.add(MoveCash.specificAmount(from, to, amount, when));
    }
  }

/*
 There's no actual limit on the amount, but this is intended for low gross monthly incomes,
 for retired people making a bit of cash to supplement their income.
*/
  final public void smallPaycheck() throws ParseException {
   String grossAmount=""; String when="";
    jj_consume_token(165);
    jj_consume_token(MONEY);
                             grossAmount=token.image;
    jj_consume_token(WHEN_CONTROL);
                                                                        when=token.image;
    scenario.transactionals.add(SmallPaycheck.valueOf(grossAmount, when));
  }

  final public void annuityPayment() throws ParseException {
  String amount=""; String when="";
    jj_consume_token(166);
    jj_consume_token(MONEY);
                              amount=token.image;
    jj_consume_token(WHEN_CONTROL);
                                                                   when=token.image;
    scenario.transactionals.add(new AnnuityPayment(when, amount));
  }

  final public void stockSplit() throws ParseException {
  String when=""; String factor=""; Set<String> tickers = new LinkedHashSet<String>();
    jj_consume_token(167);
    jj_consume_token(NUM);
          factor=token.image;
    jj_consume_token(168);
    jj_consume_token(QUOTED_TEXT);
     for(String ticker : Util.chopList(noQuotes(token.image))) {
        tickers.add(ticker);
     }
    jj_consume_token(WHEN_CONTROL);
                   when=token.image;
     scenario.transactionals.add(StockSplit.valueOf(when, tickers, factor));
  }

  /** Generated Token Manager. */
  public ScenarioParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[70];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
      jj_la1_init_5();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3000000,0x2,0x2,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x100,0x0,0x0,0x0,0x400,0x800,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x100,0x1c00,0x0,0x1c00,0xa,0x0,0x1400,0x0,0x1400,0x4000,0x4000,0x1c00,0x1e00,0x0,0x0,0x0,0x8,0x8,0x8,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x800,0x1,0x1000,0x2000,0x4000,0x10000,0x20000,0x40000,0x80000,0x100000,0x200000,0x400000,0x800000,0x1000000,0x2000000,0x4000000,0x8000000,0x10000000,0x20000000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x40000,0x0,0x800,0x10,0x8000,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e0,0x7000,0x0,0x0,0x0,0x0,0x800000,0x2000000,0x800000,0x2000000,0x800000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xd8000008,0xd8000008,0x0,0x0,0x2000000,0x18000000,0x80000000,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_5() {
      jj_la1_5 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd3,0xd3,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public ScenarioParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public ScenarioParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ScenarioParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 70; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 70; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public ScenarioParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ScenarioParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 70; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 70; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public ScenarioParser(ScenarioParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 70; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(ScenarioParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 70; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[169];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 70; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 169; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
